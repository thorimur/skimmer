/-
Copyright (c) 2025 Thomas R. Murrills. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas R. Murrills
-/
module

public meta import Skimmer.Refactor.Init
import all Lean.Elab.Declaration
import Batteries.Tactic.Alias
import Skimmer.Refactor.Edit

public meta section

open Skimmer Command Lean Meta Elab Term Command

/-! TODO: move all of this somewhere else -/

/-!
## Declarations

This section defines methods for collecting declarations and associating them with source identifiers.

One strategy for getting the source of a given declaration:

1. Encounter `Expr.const` in `TermInfo`
2. If we want to refactor its source:
3. Look up its declaration range
4. Convert to syntax range; match it to source syntax
5. Handle result

Alternatively:
1. Traverse infos; notice an info node `declId`; handle. Cons: can't handle e.g. `instance`

Alternatively (X):
2. Traverse syntax; notice a syntax node of kind `declId`.
3. PROBLEM: hard to get original.


In all of these cases, we need to persist the fact that we've handled this declaration—or at least assume so if it lives in a different source syntax. Perhaps the latter is a more appropriate strategy for now, but I think persisting info between invocations is good. A way to know that this is the first invocation that did x is probably useful (i.e. wait for all linters above you, check a ref).
-/

/-!
## Replacing names

First, we must ensure they're of the same type...sort of.

- Declarations with a renamed prefix
  - Source: this is easy enough...usually.
    - Need to infer if it has already changed due to changed scopes if autogenerated; mainly `instance` prefixes here. Proposal: just leave `instance` alone
    - Add deprecation alias after.
  - Uses:
    - dot notation: need to check that dot notation still makes sense, given prior replacements.
    - scopes: need to check that the current qualifications make sense. However, if the source is renamed, or the namespace would have been changed, we can again take this into account.

- Renaming declarations with multiple components
  - If the namespace has changed--either at the root or otherwise--and that prefix has *not* been renamed, we need to adjust the usage.
  - note that we can also encounter simultaneous deprecations e.g. `Foo.String` -> `Foo.Strang`, and `Foo.String.append` -> `Foo.String.join`. In this case, what should happen? The deprecated declaration should *not* be renamed; after all, this would mean
    `Foo.String.append` d(new)-> `Foo.Strang.append`
    `Foo.Strang.append` d-> `Foo.Strang.join` (assuming we update that too; it's in the infotree, so)
    `Foo.String.join` d(new)-> `Foo.Strang.join`.
  - note that we should avoid locals.

- Other concerns
  - Need to handle `alias`es, `protected` and `export`ed decls.
    - Need to handle the case where this changes from old to new decl.
    - Need to potentially both respect **and modify** `export` commands
    - Note: there are two notions of aliases in Lean. One is internal, used by `export` (anything else?); one is the command `alias`, which does not use the internal `alias` at all.
  - Need to modify namespaces sometimes.
  - Do we need to handle preresolved names? When do those appear, and when might a rename affect that?
  - Need to handle `@`? Does that change name resolution
  - Metaprogramming: Qq, syntax quotations. Worse: changing the name of a syntax category!
  - Ideally the deprecation case is just a matter of feeding a "name converter" `Name → CommandElabM (Option NameInfo)` to some more general infrastructure. For simple renames we can have a
  ```
  def Name.replaceWith (old new : Name) : Name → CommandElabM (Option NameInfo) := fun n =>
    if n == old then return some new else return none
  ```
  - Likewise presumably we generalize over prior parametric updates to expected type, scopes, and new "name facts". However, I think we might need to produce these new name facts in a `NameInfo` sometimes. These are facts like `protected`

- Handling markers
  - The actual `Name` in an `Expr.const` when private is something like `_private.<mod>.0.<name_we_care_about>`. See `Name.privateToUserName`.
  - Again, `unresolve` is interesting. Note that we have access to the local context via term info.

Note: a recreated frontend would actually make things easier in this specific case. We could just reset everything and re-elaborate...filemap things and basic operations like getting the correct syntax range might be awkward, though.

- Useful
  - `unresolveNameGlobal(AvoidingLocals)`
  - `resolveNameUsingNamespaces`, and `Lena.Elab.OpenDecl.State`?
  - The potential field names yielded by `resolveGlobalName` (part of `resolveGlobalConst` etc.) are interesting.
  - Reference:
    - `addLValArgs` for dot notation
    - `elabApp`
-/

namespace Ident


/-! ## Deprecation -/

def BarType := Bool

@[deprecated BarType (since := "yesterday")]
def FooType := Bool

def FooType.bar := true


def Lean.Name.matchesStemOf : Name → Name → Bool
| .str n₁ _, .str n₂ _ => n₁ == n₂
| _, _ => false

def Lean.Name.replaceLast : Name → String → Name
| .str n _, s => .str n s
| _, _ => .anonymous

/-- Like `foldInfoTree` but monadic -/
partial def Lean.Elab.InfoTree.foldInfoTreeM {m} [Monad m] (init : α) (f : ContextInfo → InfoTree → α → m α) : InfoTree → m α :=
  go none init
where
  go ctx? a
  | .context ctx t => go (ctx.mergeIntoOuter? ctx?) a t
  | t@(.node i ts) => do
    let a ← match ctx? with
      | none => pure a
      | some ctx => f ctx t a
    ts.foldlM (init := a) (go <| i.updateContext? ctx?)
  | .hole _ => pure a


/-- Replaces the fully-resolved, underlying name appearing in the expression with the new name. -/
-- TODO: generalize to replacing expressions
-- TODO: `mkReplacement` is weirdly typed
-- TODO: separate replacements from prefix replacements. Currently they're both. We assume we always replace namespaces but don't want to do that in general
-- TODO: unify replacements and mkREplacements into a generic monad interface. Set them up for our specific monad with `NameMap` and `mkReplacements`? Or something like that
-- TODO: this should only look at actual replacements
def createNewName (resolvedName : Name) (replacements : NameMap Name) : Option Name :=
  go resolvedName .anonymous
where
  go (n suffix : Name) : Option Name :=
    if let some new := replacements.get? n then
      new ++ suffix
    else
      -- TODO: be more efficient. maybe replacePrefix or such
      match n with
      | .str n s => go n (Name.str .anonymous s ++ suffix)
      | .num n k => go n (Name.num .anonymous k ++ suffix)
      | .anonymous => none

end Ident

namespace Skimmer

-- def replaceDeclId
-- Plan: right now we go through all the infotrees, looking for constants, I suppose. Could early exit by looking for matching idents based on suffixes of replacements

inductive IdentReplacement where
| compatible (i : Ident) (n : Name)
| incompatible (n : Name)
| unchangedIdent (i : Ident) (n : Name)

/-- We guess a new dotted identifier by seeing if its base is replaced. We don't replace if the resolvedName itself is deprecated -/
-- TODO: we don't handle `open` decls which may mean that we don't want the prefix per se, but a part of the prefix, e.g. `List` in `Foo.List.map` when `Foo` open
def guessNewDottedIdent (i : Ident) (resolvedName : Name) (replacements : NameMap Name) :
    Option IdentReplacement := do
  -- TODO: handle replacement generated by mkReplacement, e.g. if `resolvedName` is just deprecated
  let suffix := i.getId
  -- well-formedness
  let base ← resolvedName.eraseSuffix? suffix
  -- case: resolvedName is already something we want to replace
  if let some new := replacements.get? resolvedName then
    -- TODO: Name API
    if base.isPrefixOf new then
      let dotSuffix := new.replacePrefix base .anonymous
      return .compatible (mkIdentFrom i dotSuffix) new
    else
      return .incompatible new
  -- case: we only know we want to replace `base`. dotIdent stays the same
  else if let some new := replacements.get? base then
    return .unchangedIdent i (new ++ suffix)
  else
    failure -- do nothing

-- TODO: include `replacementKind : Name` for filtering? maybe also `reviewLevel` or something?
-- Don't really need different constructors here, could return a structure with a flag
-- have to totally revamp to decide whether should ask for strings, syntax, etc.
inductive Replacement where
| compatible (old new : Syntax) (newStr : String)
| incompatible (old new : Syntax) (newStr : String)
/-- Takes care of extra line -/
| insertCommandAfter (cmd : Syntax) (insertedCmd : Command)
deriving Inhabited, Repr

-- TODO: recursive things in foo

-- Mention no info leaves for elab* (elabExplicit, elabIdent, etc.) within elabApp
-- Might need a "usage type" but for now can just match, right?
-- Problem: guessing dotted ident will be fragile.
open Parser Term

-- #check elabIdent
/-
`elab*` > `elabAtom` > `elabAppaux` > `elabAppFn`

`elabAppFnId` for identifiers. Uses `resolveName'` to split into projections.

`resolveDottedIdentFn` for `.$_:ident`. This does the type thingy.

First pass: try the obvious thing; if it "doesn't work", restructure syntax to straightforward thing. Not working is however not determined by re-elaborating, but by attempting to resolve the name

Useful note around here about interaction between `observing?` and withoutErrToSorry; is it the obvious thing, i.e. that with errToSorry we do not throw?
-/

-- NOW TODO: currNamespace and openDecls and usage lctx at top level. We also need to not just use ContextInfo, but *replace* the open decls and such whenever we modify (1) namespace or open commands (2) modify a declId so that it creates a new namespace

-- PLAN: initialize deprecations along the way in replacements. Not great
-- Need custom unresolve per syntax + expected type potentially, including namemap
-- TODO: check Term.ident vs. Parser.ident
/-- Assumes namespaces have been used from the contextinfo of usage, and that we've replaced them appropriately for unresolveNameGlobal. Also assumes the new names have actually been added to the environment (when relevant). (TODO: recursion where it's the name of an fvar)

Cases handled: identInfo is the elaboration of some canonical syntax into an identifier
-/
def transformIdentUsage (usage : Syntax)
    -- expected type somewhere in here
    (identInfo : TermInfo)
    (replacements : NameMap Name) :
    TermElabM (Option Replacement) := do
  let some (resolvedName, _) := identInfo.expr.const? | return none
  -- TODO: proj
  -- NOW TODO: command context with namespace open decls
  match usage with
  -- TODO: need to handle `@(<app>/other term)` or is that given by infotrees
  | stx@`(Parser.ident| $_:ident) =>
    let some newName ← observing? <| unresolveNameGlobalAvoidingLocals resolvedName
      | return none -- TODO: refine. Could do better?
    return some <| .compatible stx (mkIdentFrom stx newName) newName.toString

  -- | `(explicit| @%$atSign$i:ident) => return (replacements, none) -- TODO
  | stx@`(dotIdent| .$i:ident) =>
  -- `Term.proj` (`(e).id`) is similar
    let some r := guessNewDottedIdent i resolvedName replacements | return none
    if _h : r matches .unchangedIdent .. then return none else
      match r with
      | .compatible newIdent n => return some (.compatible i newIdent n.toString)
      | .incompatible n =>
        let some newName ← observing? <| unresolveNameGlobalAvoidingLocals n
          | return none
        -- replace dotIdent with normal ident
        return some (.incompatible stx (mkIdentFrom stx newName) newName.toString)
  | _ => return none

  -- | stx =>
  --   -- TODO: explore if syntax quotations can handle this after all
  --   if stx.isOfKind ``app && stx[0].isIdent then
  --     return
  --   -- see `elabPipeProj`
  --   else if stx.isOfKind ``pipeProj then
  --     match stx with
  --     | `($e |>.%$tk$f $args*) =>
  --       return
  --     | _ => throwUnsupportedSyntax
  --   -- is rawIdent the same as ident re: Syntax.ident? I'd expect so
  --   else if stx.isOfKind ``proj && stx[2].isIdent then
  --     return
  -- -- Break down into recognized proj's + associated consts. Maybe a map

def _root_.Lean.Name.replacePrefixSome (replace? : Name → Option Name) : Name → Option Name := fun n =>
  if let some new := replace? n then new else
  match n with
  | .str p s => (.str · s) <$> replacePrefixSome replace? p
  | .num p s => (.num · s) <$> replacePrefixSome replace? p
  | .anonymous => none

open Parser Command
-- NOW TODO: two decls. one which
/--
Namespaces are *NOT* replaced.

Adds to environment; updates replacements. Adding to environment could be problematic for recursive definition, should allow us to postpone.

Ideally we have two environments, but...

Run this before entering. -/
-- NOW TODO: get infotree from environment. Something else should produce the new name; createNewName I suppose
def transformDeclIdAndCreateDeprecated (cmd : TSyntax ``declaration) (replacements : NameMap Name) :
    CommandElabM (NameMap Name × Option Replacement × Option Syntax) := runTermElabM fun vars => do
  let decl := cmd.raw[1]
  let declKind := decl.getKind
  -- TODO: only handle defs and theorems for now
  -- TODO: consider going through infotrees instead
  unless declKind == ``Parser.Command.definition || declKind == ``Parser.Command.theorem do
    return (replacements, none, none)
  -- TODO: handle modifiers...
  -- -- Note: does not rely on current namespaces, does not include current namespaces
  -- let (ns, shortenedDecl) ← if let some (ns, shortenedDecl) ← liftMacroM <| expandDeclNamespace? cmd then
  --     pure (ns, getDeclName? shortenedDecl |>.getD .anonymous)
  --   else
  --     pure (.anonymous, getDeclName? cmd |>.getD .anonymous)
  let oldDeclIdName := getDeclName? cmd |>.getD .anonymous
  -- TODO: macro scopes, visibility?, etc.
  -- TODO: generalize in case replacement is spread out over declId namespace and ambient namespace
  let (newFullName, oldFullName, newOldDeclIdName, newDeclIdName?) ← do
    if (← getCurrNamespace).isAnonymous then
      let (ns, shortName) := match oldDeclIdName with
        | .str ns s => (ns, Name.str .anonymous s)
        | s => (.anonymous, s)
      let some replacedNs := ns.replacePrefixSome replacements.get?
        | return (replacements, none, none) -- TODO: we assume the declaration is not to be replaced
      let oldDeclIdName := getDeclName? cmd |>.getD .anonymous
      pure (replacedNs ++ shortName, oldDeclIdName, oldDeclIdName, some (replacedNs ++ shortName))
    else
      let some replaced := (← getCurrNamespace).replacePrefixSome replacements.get?
        | return (replacements, none, none)
      pure
        (replaced,
        (← getCurrNamespace) ++ oldDeclIdName,
        -- Add root to command to properly namespace it. TODO: handle `namespace ... in`? does that even work?
        `_root_ ++ (← getCurrNamespace) ++ (getDeclName? cmd |>.getD .anonymous),
        -- new name is the same
        none)
  -- Deprecation command to come afterwards
  let dateStr ← IO.Process.run { cmd := "date", args := #["+\"%Y-%m-%d\""] }
  let dateStr := Syntax.mkStrLit dateStr.trim
  let deprecation ← `(command|
    @[deprecated $(mkCIdent newFullName) (since := $dateStr:str)]
    alias $(mkCIdent newOldDeclIdName) := $(mkCIdent newFullName))
  let replacements := replacements.insert oldFullName newFullName
  let declId := cmd.raw[1][1]
  if let some newId := newDeclIdName? then
    let idStx := mkIdent newId |>.raw.setInfo declId.getHeadInfo
    let (newStx, str) := if cmd.raw[1][1].isIdent then
        (idStx, newId.toString)
      else
        (declId.setArg 0 idStx, newId.toString /- ++ ? -/) -- TODO: handle universes
    return (replacements, some <| .compatible idStx newStx str, deprecation)
  else
    return (replacements, none, some <| deprecation)


-- For now we just replace namespaces dynamically...no state.

-- NOW TODO: initialize name map correctly both at top of file and after each command

-- TODO: what is `openRenamingItem`?!
-- TODO: ensure we only introduce valid namespaces.
/-- Note: ran after processing the command, so namespace in command is already active. -/
def transformNamespaceOpenEnd (replacements : NameMap Name) : Syntax → CommandElabM (Option Replacement)
  | `(command| namespace $i) => do
    if (← getCurrNamespace) = i.getId then
      let some new := (← getCurrNamespace).replacePrefixSome replacements.get? | return none
      return some <| .compatible i (mkIdentFrom i new) new.toString
    else
      return none
  | `(command| end $i) => do -- TODO: now we assume this is not a section
    if (← getCurrNamespace).isAnonymous then
      let some new := i.getId.replacePrefixSome replacements.get? | return none
      return some <| .compatible i (mkIdentFrom i new) new.toString
    else
      return none
  | `(command| open $i:ident) => do -- TODO: this doesn't make any sense in general; also doesn't take care of myriad non-ident `openDecl` syntaxes

    let some new := i.getId.replacePrefixSome replacements.get? | return none
    return some <| .compatible i (mkIdentFrom i new) new.toString
  | _ => return none

/-- Not sure I actually want to bundle this, but for now, sure -/
-- Likewise we might want to put this data in an environment extension or ref or something in general, so that we don't need to go quite so linearly, and can embed dive contributions in existing metaprograms
-- Likewise this is used sequentially esp. given imports; instead we can do things in parallel. Can infer from spec e.g. if `setup : Option _` instead or something (or different constructors, `.parallel` `.hierarchical`?)
-- σ is available to present and future imports during dive. α is available persistently. Not permanent design
structure Dive (σ) (α) where
  /-- At top of file -/
  setup /- arg: import syntax/string -/ (skimported : Array σ) : CommandElabM (σ × α)

  /-- With command already executed -/
  post (cmd : Syntax) (state : σ) (collected : α) : CommandElabM (σ × α)

  /-- At end of file -/ -- do we need this
  cleanup (eoi : Syntax) (state : σ) (collected : α) : CommandElabM (σ × α)

def _root_.Lean.Syntax.getEditRange (s : Syntax) [Monad m] [MonadError m] : m Syntax.Range := do
  let some range := s.getRange? true
    | throwError "Syntax without range:{indentD s}"
  return range

-- TODO: need an ambient ref which points to `dive` for good error throwing

def Replacement.toEdit : Replacement → CommandElabM Edit
  | .compatible old _ s => return ⟨← old.getEditRange, s⟩
  | .incompatible old _ s => do
    let some oldStr := old.reprint | throwError "Could not reprint{indentD old}"
    return ⟨← old.getEditRange, s!"review% ({oldStr} => {s})"⟩ -- TODO: completely improve, check if term, etc.
  | .insertCommandAfter cmd inserted => do
    let some e := cmd.getTailPos? true | throwError "Could not find tail pos for{indentD cmd}"
    let range : Syntax.Range := ⟨e, e⟩
    let fmt ← liftCoreM <| PrettyPrinter.ppCommand inserted
    return ⟨range, s!"\n\n{fmt.pretty' (← getOptions)}"⟩


-- Temporary. Will be extensible in some kind of RefactorM
def RefactorDeprecated : Dive (NameMap Name) (Array Edit) where
  setup skimported := do
    let mut replacements : NameMap Name := {}
    for r in skimported do
      replacements := replacements.union r
    let d := Linter.deprecatedAttr.ext.getImportedEntries (← getEnv)
    for mod in d do
      for (name, { newName?, .. }) in mod do
        if let some newName := newName? then
          replacements := replacements.insert name newName
    return (replacements, #[])
  post cmd replacements edits := do
    -- take care of isolated namespaces/open/end
    if let some r ← transformNamespaceOpenEnd replacements cmd then
      return (replacements, edits.push (← r.toEdit))
    let mut replacements := replacements
    let mut edits := edits
    -- take care of definitions
    -- TODO: handle `in` everywhere, both outside and at the term level
    if cmd.isOfKind ``declaration then
      let cmd : TSyntax ``declaration := ⟨cmd⟩
      let (replacements', cmdEdit?, deprecation?) ←
        transformDeclIdAndCreateDeprecated cmd replacements
      replacements := replacements'
      if let some newCmd := cmdEdit? then
        edits := edits.push <|← newCmd.toEdit
      if let some dep := deprecation? then
        edits := edits.push (.insertCommandAfter cmd dep)










syntax (name := reviewTermStx) "review% " "(" term " => " term ")" : term

open Lean Elab Term Tactic.TryThis
@[term_elab Skimmer.reviewTermStx] def elabReviewTerm : TermElab
  | stx@`(reviewTermStx| review% ($t₀:term => $t₁:term)), expectedType? => do
    -- NOW TODO: record stx somewhere
    let s ← withoutErrToSorry <| Term.observing <| withSynthesize <| elabTerm t₁ expectedType?
    match s with
    | .ok e s =>
      s.restore (restoreInfo := true)
      let suggestion : SuggestionText :=
        if let some s := t₁.raw.reprint then .string s else .tsyntax t₁
      let suggestion : Suggestion := {
        suggestion
      }
      addSuggestion stx suggestion
        (header := "Generated term is successful. Would you like to accept it?")
      return e
    | .error ex _ =>
      -- TODO: need to restore state for error?
      logWarningAt t₁ m!"Generated term failed with error:{indentD ex.toMessageData}"
    elabTerm t₀ expectedType?
  | _, _ => throwUnsupportedSyntax

syntax (name := diveStx) "dive" : command

def f : Bool := review% (true => false)

elab_rules : command
| `(dive) =>


#eval show TermElabM Syntax from do
  let e ← `(command|/-- a -/ @[simp] def e := true)
  return e.raw[1][1]


-- TODO: things in `elabExplicit`
-- TODO: `explicitUniv`
-- TODO: handle implicit lambda? Needed?
#check elabDotIdent
#check Elab.Term.expandArgs
#check explicitUniv


#exit

open Parser Term in
-- TODO: consider factoring into general `replaceIdent` plus something like `replace : Syntax → CommandElabM Syntax`
def replaceDeprecatedIdent : Refactor where run stx := do
  let mut acc := #[]
  let env ← getEnv
  for t in ← getInfoTrees do
    -- TODO: could certainly traverse the tree more efficiently
    -- TODO: check sharing, should be ok, but...
    acc ← t.foldInfoM (init := acc) fun ctx info acc => do
      match info with
      | .ofTermInfo ti => do
      -- TODO: we can use `foldInfoTreesM` and just check nodes that are `elabApp`s, `elabIdent`s, `elabProj`s, `elabDotIdent`s, `elabExplicit`s...? (iirc). Should find out why `elabApp`s and `elabExplicit`s don't leave the usual info leaves.
      -- match info with
      -- | .node (.ofTermInfo ti) ch => do
      --   if ti.elaborator == ``elabApp then
      --     for c in ch do
      --       match c with
      --       | .node (.ofTermInfo ti) _ => do
              -- TODO: get original range, not just canonical
        let some (name, _) := ti.expr.const? | return acc -- continue
        let some newName := Linter.getDeprecatedNewName env name | return acc -- continue
        let some range := ti.stx.getRange? (canonicalOnly := true) | return acc -- continue
        -- Time to replace:
        trace[Skimmer.Refactor] "Updating {.ofConstName name} ↦ {.ofConstName newName}"
        let isSimpleEnough ← pure (newName.matchesStemOf name) <&&> liftTermElabM do
          withReducible <| isDefEq (← getConstInfo name).type (← getConstInfo newName).type
        unless isSimpleEnough do
          trace[Skimmer.Refactor] "Too complicated!\n  \
            {.ofConstName name} ↦ {.ofConstName newName} @ {range}"
          return acc -- continue
        -- TODO: generalize, un-`!` (valid since `matchesStemOf _ _ = true`)
        let last := newName.getString!
        -- TODO: don't assume `id` is a suffix of `name` necessarily
        -- TODO: more tracing in edge cases
        match ti.stx with
        | `(dotIdent|.$id:ident)
        | `(Term.ident|$id:ident) =>
          let some range := id.raw.getRange? true | return acc
          let newId := id.getId.replaceLast last
          if newId.isAnonymous then return acc else
            return acc.push {
              range
              replacement := newId.toString
            }
        | stx => do
          if stx.isOfKind identProjKind then
            let some range := stx.getRange? true | return acc
            let newId := stx[0].getId.replaceLast last
            return acc.push {
              range
              replacement := newId.toString
            }
          else
            return acc
        --   return acc
        -- else
        --   return acc
      | _ => return acc
  return acc

initialize addRefactor replaceDeprecatedIdent

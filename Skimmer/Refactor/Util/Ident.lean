/-
Copyright (c) 2025 Thomas R. Murrills. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas R. Murrills
-/
module

public meta import Skimmer.Refactor.Init

public meta section

open Skimmer Command Lean Meta Elab Term Command

/-! TODO: move all of this somewhere else -/

/-!
## Declarations

This section defines methods for collecting declarations and associating them with source identifiers.

One strategy for getting the source of a given declaration:

1. Encounter `Expr.const` in `TermInfo`
2. If we want to refactor its source:
3. Look up its declaration range
4. Convert to syntax range; match it to source syntax
5. Handle result

Alternatively:
1. Traverse infos; notice an info node `declId`; handle. Cons: can't handle e.g. `instance`

Alternatively (X):
2. Traverse syntax; notice a syntax node of kind `declId`.
3. PROBLEM: hard to get original.


In all of these cases, we need to persist the fact that we've handled this declaration—or at least assume so if it lives in a different source syntax. Perhaps the latter is a more appropriate strategy for now, but I think persisting info between invocations is good. A way to know that this is the first invocation that did x is probably useful (i.e. wait for all linters above you, check a ref).
-/

/-!
## Replacing names

First, we must ensure they're of the same type...sort of.

- Declarations with a renamed prefix
  - Source: this is easy enough...usually.
    - Need to infer if it has already changed due to changed scopes if autogenerated; mainly `instance` prefixes here. Proposal: just leave `instance` alone
    - Add deprecation alias after.
  - Uses:
    - dot notation: need to check that dot notation still makes sense, given prior replacements.
    - scopes: need to check that the current qualifications make sense. However, if the source is renamed, or the namespace would have been changed, we can again take this into account.

- Renaming declarations with multiple components
  - If the namespace has changed--either at the root or otherwise--and that prefix has *not* been renamed, we need to adjust the usage.
  - note that we can also encounter simultaneous deprecations e.g. `Foo.String` -> `Foo.Strang`, and `Foo.String.append` -> `Foo.String.join`. In this case, what should happen? The deprecated declaration should *not* be renamed; after all, this would mean
    `Foo.String.append` d(new)-> `Foo.Strang.append`
    `Foo.Strang.append` d-> `Foo.Strang.join` (assuming we update that too; it's in the infotree, so)
    `Foo.String.join` d(new)-> `Foo.Strang.join`.
  - note that we should avoid locals.

- Other concerns
  - Need to handle `alias`es, `protected` and `export`ed decls.
    - Need to handle the case where this changes from old to new decl.
    - Need to potentially both respect **and modify** `export` commands
    - Note: there are two notions of aliases in Lean. One is internal, used by `export` (anything else?); one is the command `alias`, which does not use the internal `alias` at all.
  - Need to modify namespaces sometimes.
  - Do we need to handle preresolved names? When do those appear, and when might a rename affect that?
  - Need to handle `@`? Does that change name resolution
  - Metaprogramming: Qq, syntax quotations. Worse: changing the name of a syntax category!
  - Ideally the deprecation case is just a matter of feeding a "name converter" `Name → CommandElabM (Option NameInfo)` to some more general infrastructure. For simple renames we can have a
  ```
  def Name.replaceWith (old new : Name) : Name → CommandElabM (Option NameInfo) := fun n =>
    if n == old then return some new else return none
  ```
  - Likewise presumably we generalize over prior parametric updates to expected type, scopes, and new "name facts". However, I think we might need to produce these new name facts in a `NameInfo` sometimes. These are facts like `protected`

- Handling markers
  - The actual `Name` in an `Expr.const` when private is something like `_private.<mod>.0.<name_we_care_about>`. See `Name.privateToUserName`.
  - Again, `unresolve` is interesting. Note that we have access to the local context via term info.

Note: a recreated frontend would actually make things easier in this specific case. We could just reset everything and re-elaborate...filemap things and basic operations like getting the correct syntax range might be awkward, though.

- Useful
  - `unresolveNameGlobal(AvoidingLocals)`
  - `resolveNameUsingNamespaces`, and `Lena.Elab.OpenDecl.State`?
  - The potential field names yielded by `resolveGlobalName` (part of `resolveGlobalConst` etc.) are interesting.
  - Reference:
    - `addLValArgs` for dot notation
    - `elabApp`
-/


/-! ## Deprecation -/

def BarType := Bool

@[deprecated BarType (since := "yesterday")]
def FooType := Bool

def FooType.bar := true


def Lean.Name.matchesStemOf : Name → Name → Bool
| .str n₁ _, .str n₂ _ => n₁ == n₂
| _, _ => false

def Lean.Name.replaceLast : Name → String → Name
| .str n _, s => .str n s
| _, _ => .anonymous

/-- Like `foldInfoTree` but monadic -/
partial def Lean.Elab.InfoTree.foldInfoTreeM {m} [Monad m] (init : α) (f : ContextInfo → InfoTree → α → m α) : InfoTree → m α :=
  go none init
where
  go ctx? a
  | .context ctx t => go (ctx.mergeIntoOuter? ctx?) a t
  | t@(.node i ts) => do
    let a ← match ctx? with
      | none => pure a
      | some ctx => f ctx t a
    ts.foldlM (init := a) (go <| i.updateContext? ctx?)
  | .hole _ => pure a

open Parser Term in
-- TODO: consider factoring into general `replaceIdent` plus something like `replace : Syntax → CommandElabM Syntax`
def replaceDeprecatedIdent : Refactor where run stx := do
  let mut acc := #[]
  let env ← getEnv
  for t in ← getInfoTrees do
    -- TODO: could certainly traverse the tree more efficiently
    -- TODO: check sharing, should be ok, but...
    acc ← t.foldInfoM (init := acc) fun ctx info acc => do
      match info with
      | .ofTermInfo ti => do
      -- TODO: we can use `foldInfoTreesM` and just check nodes that are `elabApp`s, `elabIdent`s, `elabProj`s, `elabDotIdent`s, `elabExplicit`s...? (iirc). Should find out why `elabApp`s and `elabExplicit`s don't leave the usual info leaves.
      -- match info with
      -- | .node (.ofTermInfo ti) ch => do
      --   if ti.elaborator == ``elabApp then
      --     for c in ch do
      --       match c with
      --       | .node (.ofTermInfo ti) _ => do
              -- TODO: get original range, not just canonical
        let some (name, _) := ti.expr.const? | return acc -- continue
        let some newName := Linter.getDeprecatedNewName env name | return acc -- continue
        let some range := ti.stx.getRange? (canonicalOnly := true) | return acc -- continue
        -- Time to replace:
        trace[Skimmer.Refactor] "Updating {.ofConstName name} ↦ {.ofConstName newName}"
        let isSimpleEnough ← pure (newName.matchesStemOf name) <&&> liftTermElabM do
          withReducible <| isDefEq (← getConstInfo name).type (← getConstInfo newName).type
        unless isSimpleEnough do
          trace[Skimmer.Refactor] "Too complicated!\n  \
            {.ofConstName name} ↦ {.ofConstName newName} @ {range}"
          return acc -- continue
        -- TODO: generalize, un-`!` (valid since `matchesStemOf _ _ = true`)
        let last := newName.getString!
        -- TODO: don't assume `id` is a suffix of `name` necessarily
        -- TODO: more tracing in edge cases
        match ti.stx with
        | `(dotIdent|.$id:ident)
        | `(Term.ident|$id:ident) =>
          let some range := id.raw.getRange? true | return acc
          let newId := id.getId.replaceLast last
          if newId.isAnonymous then return acc else
            return acc.push {
              range
              replacement := newId.toString
            }
        | stx => do
          if stx.isOfKind identProjKind then
            let some range := stx.getRange? true | return acc
            let newId := stx[0].getId.replaceLast last
            return acc.push {
              range
              replacement := newId.toString
            }
          else
            return acc
        --   return acc
        -- else
        --   return acc
      | _ => return acc
  return acc

initialize addRefactor replaceDeprecatedIdent
